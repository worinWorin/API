#include <windows.h>
#include "resource.h"

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);                  // CALLBACK 매크로
HINSTANCE g_hInst;                                                     // 인스턴스 핸들
LPCTSTR lpszClass = TEXT("김연우_16032018");                           // 제목 표시줄의 내용 

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance
	, LPSTR lpszCmdParam, int nCmdShow)                                // main 함수
{
	HWND hWnd;                                                         // 원도우 핸들 선언
	MSG Message;                                                       // 메세지 구조체 변수 선언
	WNDCLASS WndClass;                                                 // Window Class 구조체 변수 선언
	g_hInst = hInstance;                                               // hinstance 값을 외부에서도 사용할 수 있도록 전역변수에 값을 저장

	WndClass.cbClsExtra = 0;                                           // 예약 영역
	WndClass.cbWndExtra = 0;                                           // 예약 영역
	WndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);      // 원도우의 배경 색상 
	WndClass.hCursor = LoadCursor(NULL, IDC_ARROW);                    // 원도우의 마우스 포인터 모양 
	WndClass.hIcon = LoadIcon(NULL, IDI_APPLICATION);                  // 원도우의 커서 모양
	WndClass.hInstance = hInstance;                                    // 원도우 클래스를 등록하는 프로그램 번호
	WndClass.lpfnWndProc = WndProc;                                    // 원도우 메세지 처리 함수 지정
	WndClass.lpszClassName = lpszClass;                                // 원도우 클래스의 이름 지정
	WndClass.lpszMenuName = MAKEINTRESOURCE(IDR_MENU1);                                      // 이프로그램의 메뉴 지정
	WndClass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;             // 원도우의 스타일을 정의
	RegisterClass(&WndClass);                                          // WNDCLASS 구조체의 번지를 전달

	// 원도우 생성
	hWnd = CreateWindow(lpszClass, lpszClass, WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
		NULL, (HMENU)NULL, hInstance, NULL);
	ShowWindow(hWnd, nCmdShow);
	// 메세지 루프를 실행

	while (GetMessage(&Message, NULL, 0, 0)) {                         // Queue에 있는 메세지를 읽어들인다.
		TranslateMessage(&Message);                                    // 키보드 입력 메세지를 가공하여 프로그램에서 쉅게 사용할수있도록
		DispatchMessage(&Message);                                     // 메세지를 원도우의 메세지 처리 함수 WndProc로 전달
	}
	return (int)Message.wParam;                                        // 탈출 코드 프로그램 종료
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	HDC hdc;
	PAINTSTRUCT ps;
	static int xPos, yPos, endX, endY;
	static int br, bg, bb, pr, pg, pb, Select;
	static BOOL buttonFlag = FALSE;
	static int size = 0;
	HBRUSH myBrush, oldBrush;
	HPEN myPen, oldPen;

	switch (iMessage)
	{
	case WM_CREATE:
		br = bg = bb = 0;
		pr = pg = pb = 0;
		Select = 0;
		return 0;


	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		// 도형 모양

		case ID_Line:			// 직선
			Select = 1;
			break;

		case ID_Circle:			// 원
			Select = 2;
			break;

		case ID_Rectangle:		// 사각형
			Select = 3;
			break;

		//	도형 색상

		case ID_Red:			// 빨강
			br = 255;
			bg = bb = 0;
			break;

		case ID_Green:			// 초록
			bg = 255;
			br = bb = 0;
			break;

		case ID_Blue:			// 파랑
			bb = 255;
			br = bg = 0;
			break;

		// 선 색상

		case ID_RedP:			// 선 - 빨강
			pr = 255;
			pg = pb = 0;
			break;

		case ID_GreenP:			// 선 - 초록
			pg = 255;
			pb = pb = 0;
			break;

		case ID_BlueP:			// 선 - 파랑
			pb = 255;
			pg = pr = 0;
			break;

		// 선 굵기

		case ID_UP10:			// +10
			size += 10;
			break;

		case ID_UP20:			// +20
			size += 20;
			break;

		case ID_UP30:			// +30
			size += 30;
			break;

		case ID_DOWN10:			// -10
			size -= 10;
			break;
		}
		return 0;

	case WM_LBUTTONDOWN:
		xPos = LOWORD(lParam);
		yPos = HIWORD(lParam);
		endX = xPos;
		endY = yPos;
		buttonFlag = TRUE;
		return 0;

	case WM_LBUTTONUP:
		buttonFlag = FALSE;
		return 0;

	case WM_MOUSEMOVE:
		if (buttonFlag == TRUE)
		{
			hdc = GetDC(hWnd);

			SetROP2(hdc, R2_NOTXORPEN);
			myBrush = CreateSolidBrush(RGB(br, bg, bb));
			oldBrush = (HBRUSH)SelectObject(hdc, myBrush);
			myPen = CreatePen(PS_SOLID, 2 + size, RGB(pr, pg, pb));
			oldPen = (HPEN)SelectObject(hdc, myPen);


			if (Select == 1)
			{
				MoveToEx(hdc, xPos, yPos, NULL);
				LineTo(hdc, endX, endY);

				MoveToEx(hdc, endX, endY, NULL);
				endX = LOWORD(lParam);
				endY = HIWORD(lParam);
				LineTo(hdc, endX, endY);
			}
			else if (Select == 2)
			{
				MoveToEx(hdc, xPos, yPos, NULL);
				Ellipse(hdc, xPos, yPos, endX, endY);

				MoveToEx(hdc, xPos, yPos, NULL);
				endX = LOWORD(lParam);
				endY = HIWORD(lParam);
				Ellipse(hdc, xPos, yPos, endX, endY);
			}
			else if (Select == 3)
			{
				MoveToEx(hdc, xPos, yPos, NULL);
				Rectangle(hdc, xPos, yPos, endX, endY);

				MoveToEx(hdc, xPos, yPos, NULL);
				endX = LOWORD(lParam);
				endY = HIWORD(lParam);
				Rectangle(hdc, xPos, yPos, endX, endY);
			}

			SelectObject(hdc, oldBrush);
			DeleteObject(myBrush);
			SelectObject(hdc, oldPen);
			DeleteObject(myPen);
			ReleaseDC(hWnd,hdc);
		}
		return 0;


	case WM_LBUTTONDBLCLK:
		InvalidateRect(hWnd, NULL, TRUE);
		return 0;

	case WM_DESTROY:
		PostQuitMessage(1);
		return 0;
	}
	return(DefWindowProc(hWnd, iMessage, wParam, lParam));
}
